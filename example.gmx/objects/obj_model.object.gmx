<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_create_animation_vertex_format();//create animation format.

//load multiple animations
animation_glass = scr_load_animation("./glass_animation.bao",true); //first argument: file-path, second argument: activate animation-looping.
animation_torus = scr_load_animation("./torus_explode.bao",false);//this animation isn't looped
animation_cube_deform = scr_load_animation("./cube_deform.bao",true);//this animation is looped

/*if you want to delete a model afterwards (to free up some memory) you can always call the "scr_delete_animation()" script.
Example:
scr_delete_animation(animation_cube_deform); &gt;&gt;&gt; deletes the cube animation.
*/

animation_length = room_speed*7; //specify the animation length for 1 animation loop (room_speed*4 = 4 seconds)
animation_step = 0;//this variable is holding the current animation progress (leave it to 0)

//only for the ability to change between this 3 animations on the fly in this example
current_animation = animation_glass;//the currently used animation
current_animation_number = 0;//the number of this animation. (0 = glass, 1 = torus, 2 = cube)




//------------------------------------shader variables--------------------------------

//interpolation value
global.shader_interpol = shader_get_uniform(sh_blend, "u_interpol"); //make it global, so that the "scr_draw_animation_frame" script can call it from anywhere in the project
//WARNING! This variable must be named "global.shader_interpol"! Don't change the name unless you want to edit the variable name in the scripts!

//define light uniforms
shader_ambientColor = shader_get_uniform(sh_blend, "uAmbientColor"); //ambient light (color) 
shader_lightDirection = shader_get_uniform(sh_blend, "uLightingDirection"); //direction of directional light
shader_lightDirectionalColor = shader_get_uniform(sh_blend, "uDirectionalColor"); //color of directional light

//world matrix for normal-calculation
shader_worldMatTranspInv = shader_get_uniform(sh_blend,"uMatWorldTransInv");


z = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//---- animate
animation_step+=+1;
if (animation_step&gt;=animation_length){
    animation_step = 0;
}
//----------------------
if(keyboard_check_pressed(vk_enter)){
    current_animation_number+=+1;
    if(current_animation_number&gt;=3){
        current_animation_number = 0;
    }
    
    switch (current_animation_number){
        case 0:
            current_animation = animation_glass;
        break;
        case 1:
            current_animation = animation_torus;
        break;
        case 2:
            current_animation = animation_cube_deform;
        break;
    }
    
    //reset animation progress to 0. (animation starts from the beginning
    animation_step = 0;
}


if(keyboard_check(vk_up)){
    animation_length+=-1;
    if(animation_length&lt;=2){animation_length = 2;}
}

if(keyboard_check(vk_down)){
    animation_length+=+1;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//deletes the 3D models from memory
scr_delete_animation(animation_glass);
scr_delete_animation(animation_torus);
scr_delete_animation(animation_cube_deform);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    var pc = (animation_step/animation_length);
    var frame_count = ds_list_size(current_animation);
    
    
    var currentframe = floor(pc*frame_count);
    var nextframe = currentframe+1;
    if (nextframe &gt;= frame_count){nextframe=0;};
    
draw_text(0,16,"Interpolating between frame: "+string(currentframe+1)+"-"+string(nextframe+1));
draw_text(0,32,"Interpolation value: "+string(pc*frame_count-floor(pc*frame_count)));
draw_text(0,48,"animation-length (in seconds): "+string(animation_length/room_speed));
draw_text(0,64,"Current animation-number: "+string(current_animation_number));


draw_text(0,96,"* Press &amp; hold the left mouse button to move the camera.#* Use the mouse wheel to zoom in and out.##* Press [ENTER] to change the animation.#* Use the up/down arrow keys to change the animation speed.");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);

//IMPORTANT: texture_set_repeat(true); must be enabled, in order to display textures properly.
texture_set_repeat(true);

//use animation shader
shader_set(sh_blend);

    //set lighting
    shader_set_uniform_f(shader_ambientColor,0.3,0.3,0.3);
    shader_set_uniform_f(shader_lightDirection,0.5,-0.5,0.5);
    shader_set_uniform_f(shader_lightDirectionalColor,1,1,1);
    
    
    
    //!! Apply your transformations here(like rotation and/or translation) if you want.
    // Transformations ----

    //for the normalmatrix (If your rotate the object with the d3d_transform functions, the light will normaly rotate with the applied transformation.
    //this fixes the issue by passing the modified world matrix into the shader, and multiplying it with the normals.
    //IMPORTANT! do this AFTER you applied your transformations!
    var worldMat = scr_TranspoInverse(matrix_get(matrix_world));
    shader_set_uniform_f_array(shader_worldMatTranspInv,worldMat);
    
    
    //draw animation
    /*
    the first argument is the pointer to the loaded 3D animation (in this example: animation_glass, animation_torus and animation_cube_deform from the create event.
    The second argument is the current animation progress, a value between 0 and the third parameter (animation length)
    The draw-script calculates the animation-progress with the help of this 2 values.
    
    So if animation step has the value 3 and animation_length has the value 6, then this means that you are exactly in the middle of your animation (animation progress 50%).
    
    The last parameter is a texture for the 3D model.
    */
    
     scr_draw_animation_frame(current_animation,animation_step,animation_length,background_get_texture(bg_texture));
    
     d3d_transform_set_identity();
shader_reset();
   
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
