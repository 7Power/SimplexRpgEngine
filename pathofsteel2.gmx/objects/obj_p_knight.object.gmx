<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_p_char</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

active = 0;
attacking = 0;
safe = 0;
selected = 0;
endurance = 20;
dmg = 8;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();


if (instance_place (x, y, obj_safe))
{
    self.safe = 1;
} else self.safe = 0;

// The main reasoning behind this code is determing what cells the character can reach on the grid.

var cols = ds_grid_width (move_grid);
var rows = ds_grid_height (move_grid);
var grid_x = x - gridsize * move_cells;
var grid_y = y - gridsize * move_cells;
var path = path_add();
ds_grid_clear(move_grid, 0);

var c, r;
for (c = 0; c &lt; cols; c++)
{
    for (r = 0; r &lt; rows; r++)
    {
        var tx = grid_x + c * gridsize;
        var ty = grid_y + r * gridsize;
        if mp_grid_path(global.grid, path, x, y, tx, ty, false)
        {
            if (path_get_length (path) &gt; move_range) || (path_get_length(path) &lt; gridsize div 2)
            {
                ds_grid_set (move_grid, c, r, 1);
            } else ds_grid_set (move_grid, c, r, 0);
        }
        else ds_grid_set (move_grid, c, r, 1);
    }
}

path_delete (path);

var acols = ds_grid_width (attack_grid);
var arows = ds_grid_height (attack_grid);
var agrid_x = x - gridsize * attack_cells;
var agrid_y = y - gridsize * attack_cells;
var path = path_add();
ds_grid_clear(attack_grid, 0);

var ac, ar;
for (ac = 0; ac &lt; acols; ac++)
{
    for (ar = 0; ar &lt; arows; ar++)
    {
        var atx = agrid_x + ac * gridsize;
        var aty = agrid_y + ar * gridsize;
        if mp_grid_path(global.grid, path, x, y, atx, aty, false)
        {
            if (path_get_length (path) &gt; attack_range) || (path_get_length(path) &lt; gridsize div 2)
            {
                ds_grid_set (attack_grid, ac, ar, 1);
            } else ds_grid_set (attack_grid, ac, ar, 0);
        }
        else ds_grid_set (attack_grid, ac, ar, 1);
    }
}

path_delete (path);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (self.myTurn == 1 &amp;&amp; obj_control.someoneMoving == 0 &amp;&amp; !instance_exists(obj_move))
{
    self.selected = 1;
    
    if (self.x &lt;= 1216 &amp;&amp; self.x &gt;= 64 &amp;&amp; self.y &gt;= 80)
    {
        instance_create(self.x - 20, self.y - 47, obj_move);
        instance_create(self.x, self.y - 47, obj_attack);
        instance_create(self.x + 20, self.y - 47, obj_cancel);
    }
    
    // Finish out the map spaces
    
}

if (self.active == 1 &amp;&amp; self.selected == 0 &amp;&amp; obj_control.someoneMoving == 1)
{
    self.active = 0;
    obj_control.someoneMoving = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (self.active == 1)
{
    if (mouse_check_button_pressed (mb_left))
    {
        if (!place_meeting(mouse_x, mouse_y, obj_p_knight))
        {
            var mx = (mouse_x div gridsize * gridsize + 32);
            var my = (mouse_y div gridsize * gridsize + 32);
            mp_grid_clear_cell (global.grid, x div gridsize, y div gridsize);
            if (mp_grid_path(global.grid, path, x, y, mx, my + 16, false))
            {
                path_start(path, 0, 0, true);
                pathDest = min (1/path_get_length(path_index) * gridsize * move_cells, 1)
            }
        }
    }
}

// Need to add code for attacking, including ranged

if (self.attacking == 1)
{
    if (mouse_check_button_pressed (mb_left))
    {
        if (place_meeting(mouse_x, mouse_y, obj_p_enemy))
        {
            var mx = (mouse_x div gridsize * gridsize + 32);
            var my = (mouse_y div gridsize * gridsize + 32);
            var target = instance_nearest(mx, my, obj_p_enemy);
            if (point_distance(x, y, target.x, target.y) &lt; 65)
            {
                with (target)
                {
                    self.endurance -= other.dmg;
                }
                self.ap -= 1;
                self.attacking = 0;
                obj_control.someoneMoving = 0;
                if (self.ap == 0)
                {
                    self.myTurn = 0;
                    obj_control.thisTurn += 1;
                    obj_control.dish = 1;
                }
            }
        } else 
        {
            self.attacking = 0;
            obj_control.someoneMoving = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var cols = ds_grid_width(move_grid);
var rows = ds_grid_height(move_grid);
var grid_x = x - gridsize * move_cells;
var grid_y = y - gridsize * move_cells;
var c, r;
var hg = gridsize div 2;

if (self.active == 1 &amp;&amp; pathDest &lt;= 0)
{
    mp_grid_clear_cell (global.grid, x div gridsize, y div gridsize);
    for (c = 0; c &lt; cols; c++)
    {
        for (r = 0; r &lt; rows; r++)
        {
            if (ds_grid_get (move_grid, c, r) == 0)
            {
                var tx = grid_x + c * gridsize;
                var ty = grid_y + r * gridsize;
                
                draw_set_alpha (0.5);
                draw_set_color (c_white);
                draw_rectangle (tx - 16, ty - 16, tx - 16 + hg, ty - 16 + hg, false);
                draw_set_alpha (1);
            }
        }
    }
}

var acols = ds_grid_width(attack_grid);
var arows = ds_grid_height(attack_grid);
var agrid_x = x - gridsize * attack_cells;
var agrid_y = y - gridsize * attack_cells;
var ac, ar;
var hg = gridsize div 2;


if (self.attacking == 1)
{
    mp_grid_clear_cell (global.grid, x div gridsize, y div gridsize);
    for (ac = 0; ac &lt; acols; ac++)
    {
        for (ar = 0; ar &lt; arows; ar++)
        {
            if (ds_grid_get (attack_grid, ac, ar) == 0)
            {
                var atx = agrid_x + ac * gridsize;
                var aty = agrid_y + ar * gridsize;
                
                draw_set_alpha (0.5);
                draw_set_color (c_red);
                draw_rectangle (atx - 16, aty - 16, atx - 16 + hg, aty - 16 + hg, false);
                draw_set_alpha (1);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
