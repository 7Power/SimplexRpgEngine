<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sNoone</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_create_animation_vertex_format();//create animation format.

//load multiple animations
animation_glass = scr_load_animation("./glass_animation.bao",true); 

animation_length = room_speed*7; //specify the animation length for 1 animation loop (room_speed*4 = 4 seconds)
animation_step = 0;//this variable is holding the current animation progress (leave it to 0)

//only for the ability to change between this 3 animations on the fly in this example
current_animation = animation_glass;//the currently used animation
current_animation_number = 0;//the number of this animation. (0 = glass, 1 = torus, 2 = cube)




//------------------------------------shader variables--------------------------------

//interpolation value
global.shader_interpol = shader_get_uniform(sh_blend, "u_interpol"); //make it global, so that the "scr_draw_animation_frame" script can call it from anywhere in the project
//WARNING! This variable must be named "global.shader_interpol"! Don't change the name unless you want to edit the variable name in the scripts!

//define light uniforms
shader_ambientColor = shader_get_uniform(sh_blend, "uAmbientColor"); //ambient light (color) 
shader_lightDirection = shader_get_uniform(sh_blend, "uLightingDirection"); //direction of directional light
shader_lightDirectionalColor = shader_get_uniform(sh_blend, "uDirectionalColor"); //color of directional light

//world matrix for normal-calculation
shader_worldMatTranspInv = shader_get_uniform(sh_blend,"uMatWorldTransInv");


z = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>animation_step+=+1;
if (animation_step&gt;=animation_length){
    animation_step = 0;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);

//IMPORTANT: texture_set_repeat(true); must be enabled, in order to display textures properly.
texture_set_repeat(true);

//use animation shader
shader_set(sh_blend);

    //set lighting
    shader_set_uniform_f(shader_ambientColor,0.3,0.3,0.3);
    shader_set_uniform_f(shader_lightDirection,0.5,-0.5,0.5);
    shader_set_uniform_f(shader_lightDirectionalColor,1,1,1);
    
    
    
    //!! Apply your transformations here(like rotation and/or translation) if you want.
    // Transformations ----
d3d_transform_set_rotation_z(direction)
d3d_transform_set_scaling(3,3,3);
d3d_transform_add_translation(x,y,z)
    //for the normalmatrix (If your rotate the object with the d3d_transform functions, the light will normaly rotate with the applied transformation.
    //this fixes the issue by passing the modified world matrix into the shader, and multiplying it with the normals.
    //IMPORTANT! do this AFTER you applied your transformations!
    var worldMat = scr_TranspoInverse(matrix_get(matrix_world));
    shader_set_uniform_f_array(shader_worldMatTranspInv,worldMat);
    
    
    //draw animation
    /*
    the first argument is the pointer to the loaded 3D animation (in this example: animation_glass, animation_torus and animation_cube_deform from the create event.
    The second argument is the current animation progress, a value between 0 and the third parameter (animation length)
    The draw-script calculates the animation-progress with the help of this 2 values.
    
    So if animation step has the value 3 and animation_length has the value 6, then this means that you are exactly in the middle of your animation (animation progress 50%).
    
    The last parameter is a texture for the 3D model.
    */
    
     scr_draw_animation_frame(current_animation,animation_step,animation_length,background_get_texture(bg_texture));
    
     d3d_transform_set_identity();
shader_reset();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
